onramp:
  - id: udp
    type: udp
    codec: json
    config:
      host: 127.0.0.1
      port: 12202

offramp:
  - id: console
    type: stdout
    config:
      prefix: 'UDP: '

binding:
  - id: udp
    links:
      '/onramp/udp/{instance}/out': [ '/pipeline/main/{instance}/in' ]
      '/pipeline/main/{instance}/out': [ '/offramp/console/{instance}/in' ]
      '/pipeline/main/{instance}/error': [ '/offramp/system::stderr/{instance}/in' ]

mapping:
  /binding/udp/01:
    instance: '01'

pipeline:
  - id: main
    interface:
      inputs:
        - in
      outputs:
        - out
        - error
    nodes:
      - id: counter-op
        op: generic::counter
      - id: counter-script
        op: runtime::tremor
        config:
          script: |
            match state of
              case %{present count} =>
                let state.count = state.count + 1
              default =>
                let state.count = 1
            end;

            # simulates what the generic::counter operator does
            {
              "count_via_script": state.count,
              "event": event
            }
      - id: events-script
        op: runtime::tremor
        config:
          script: |
            # TODO fix initial state as null
            #match state of
            #  case null =>
            #    let state = [event]
            #  default =>
            #    let state = array::push(state, event)
            #end;
            #
            #state

            match state of
              case %{present events} =>
                let state.events = array::push(state.events, event)
              default =>
                let state.events = [event]
            end;

            state.events
    links:
      in: [ counter-op, counter-script, events-script ]
      counter-op: [ out ]
      counter-script: [ out ]
      counter-script/error: [ error ]
      events-script: [ out ]
      events-script/error: [ error ]

// Copyright 2018-2019, Wayfair GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::ast::*;
use crate::lexer;
use crate::lexer::Token;
use crate::pos::Location;
use crate::tilde::Extractor;
use simd_json::BorrowedValue as Value;
use std::borrow::Cow;

grammar<'input>;

////////////////////////////// Root statements //////////////////////////////
// These statments for the root of the language.

/// Root
pub Query : Query1<'input> = {
    <stmts:Stmts> "<end-of-stream>"? => Query1{stmts},
}

Stmts: Stmts1<'input> = {
  <stmt:Stmt> ";" <list:Stmts> => {
    let mut list = list;
    list.insert(0,stmt);
    list
  },
  <item:Stmt> ";"? => vec![item],
}

WindowKind: WindowKind = {
  "sliding" => WindowKind::Sliding,
  "tumbling" => WindowKind::Tumbling,
}

Stmt: Stmt1<'input> = {
    <start:@L> "define" <kind:WindowKind> "window" <id:Ident> <params:WithScriptClause> <end:@L> => Stmt1::WindowDecl(WindowDecl1 { start, end, id: id.id.to_string(), kind, params: params.0, script: params.1 }),
    <start:@L> "define" <kind:OperatorKind> "operator" <id:Ident> <params:WithClause> <end:@L> => Stmt1::OperatorDecl(OperatorDecl1 { start, end, kind, id: id.id.to_string(), params }),
    <start:@L> "define" "script" <id:Ident> <params:WithClause> <script:EmbeddedScript> <end:@L> => Stmt1::ScriptDecl(ScriptDecl1 { start, end, id: id.id.to_string(), script, params }),
    <start:@L> "create" "stream" <id:Ident> <end:@L> => Stmt1::Stream(StreamStmt { start, end, id: id.id.to_string() }),
    <start:@L> "create" "operator" <id:Ident> "from" <target:Ident> <params:WithClause> <end:@L> => Stmt1::Operator(OperatorStmt1 { start, end, id: id.id.to_string(), target: target.id.to_string(), params }),
    <start:@L> "create" "script" <id:Ident> "from" <target:Ident> <params:WithClause> <end:@L> => Stmt1::Script(ScriptStmt1 { start, end, id: id.id.to_string(), target: target.id.to_string(), params }),
    <start:@L> "select" <target:ExprImut> "from" <from:StreamPort> <windows:WindowClause> <maybe_where:WhereClause> <maybe_group_by:GroupByClause> "into" <into:StreamPort> <maybe_having:HavingClause> <end:@L> => Stmt1::Select(Box::new(MutSelect1 { start, end, from, into, target, maybe_where, maybe_having, windows, maybe_group_by})),
}

MaybePort: Option<Ident<'input>> = {
    ("/" <Ident>)? => <>,
}

StreamPort: (Ident<'input>, Option<Ident<'input>>) = {
    <op:Ident> <port:MaybePort> => (op, port)
}

WindowClause: Option<Vec<WindowDefn1>> = {
    (<WindowDefn>)? => <>,
}

Window: WindowDefn1 = {
    <start:@L> <id:Ident> <end:@L> => WindowDefn1 { start, end, id: id.id.to_string() },
}

Windows: Vec<WindowDefn1> = {
    <fields:Windows_> => {
        let mut fields = fields;
        fields.reverse();
        fields
    },
}

Windows_: Vec<WindowDefn1> = {
    <Sep<Windows_, Window, ",">> => <>
}


WindowDefn: Vec<WindowDefn1>  = {
    "[" <windows:Windows> "]" => windows
}

WhereClause: Option<ImutExpr1<'input>> = {
    ("where" <ComplexExprImut>)? => <>,
}

HavingClause: Option<ImutExpr1<'input>> = {
    ("having" <ComplexExprImut>)? => <>,
}

GroupByClause: Option<GroupBy1<'input>> = {
    ("group" "by" <GroupDef>)? => <>
}


GroupDef: GroupBy1<'input> = {
    <start:@L> <expr:ExprImut> <end:@L> => GroupBy1::Expr{start, expr, end},
    <start:@L> "set" "("<items:GroupDefs>")" <end:@L> => GroupBy1::Set{start, items, end},
    <start:@L> "each" "("<expr:ExprImut>")" <end:@L> => GroupBy1::Each{start, expr, end},
}


GroupDefs: Vec<GroupBy1<'input>> = {
    <fields:GroupDefs_> => {
        let mut fields = fields;
        fields.reverse();
        fields
    },
}

GroupDefs_: Vec<GroupBy1<'input>> = {
    <Sep<GroupDefs_, GroupDef, ",">> => <>
}

EmbeddedScriptImut: Option<Script1<'input>> = {
    ("script" <ExprImut>)? => Some(Script1{exprs: vec![Expr1::Imut(<>?)]}),
}

WithScriptClause: (WithExprs1<'input>, Option<Script1<'input>>) = {
    "with" <with:WithExprs> <script:EmbeddedScriptImut> "end" => (with, script),
}




WithClause: Option<WithExprs1<'input>> = {
    ("with" <WithExprs> "end")? => <>,
}


WithExprs: WithExprs1<'input> = {
    <fields:WithExprs_> => {
        let mut fields = fields;
        fields.reverse();
        fields
    },
}

WithExprs_: WithExprs1<'input> = {
    <Sep<WithExprs_, WithExpr, ",">> => <>
}

WithExpr: (Ident<'input>, ImutExpr1<'input>) = {
    <start:@L> <name:Ident> "=" <expr:ExprImut> => (name, expr)
}

OperatorKind: OperatorKind = {
    <start:@L> <module:Ident> "::" <oper:Ident> <end:@L> => OperatorKind { start, end, module:  module.id.to_string(), operation: oper.id.to_string() }
}

EmbeddedScript: Script1<'input> = {
    "script" <exprs:Exprs> "end" => Script1{exprs},
}


///////////////////////////////////////

pub Script : Script1<'input> = {
    <exprs:Exprs> "<end-of-stream>"? => Script1{exprs},
}

/// List of expressions at the root of the script
Exprs: Exprs1<'input> = {
    <expr:MayBeConstExpr> ";" <list:Exprs> => {
       let mut list = list;
       list.insert(0,expr);
       list
    },
    <item:MayBeConstExpr> ";"? => vec![item],
}

MayBeConstExpr: Expr1<'input> = {
     Const => <>,
     Expr => <>
}

/// A const expressions (this gets compiled out during the 2nd phjase)
Const: Expr1<'input> = {
    <start:@L> "const" <name:Ident> @L "=" @R <expr:SimpleExprImut> <end:@L> => Expr1::Const{name: name.id, expr: expr, start, end},
}

////////////////////////////// Expr (mutable) //////////////////////////////
// Expressions are the fundamental building block of the language
// starting form binary operators to more complex things like match
// statements

/// Expression root
Expr: Expr1<'input> = {
    SimpleExpr => <>,
}

/// Non precedence based expressions and language constructs
SimpleExpr: Expr1<'input> = {
    <pp:Match> => Expr1::MatchExpr(Box::new(pp)),
    <comprehension:For> => Expr1::Comprehension(Box::new(comprehension)),
    Let => <>,
    Drop => <>,
    Emit => <>,
    ExprImut => <>.into(),
}

/// Part of the expressions that are always imutable
AlwaysImutExpr: ImutExpr1<'input> = {
    <pp:Patch> => ImutExpr1::Patch(Box::new(pp)),
    <pp:Merge> => ImutExpr1::Merge(Box::new(pp)),
    <call:InvokeAggr> => ImutExpr1::InvokeAggr(call),
    <call:Invoke> => ImutExpr1::Invoke(call),
    <literal:Literal> => ImutExpr1::Literal(literal),
    <path:Path> => ImutExpr1::Path(path),
    <record:Record> => ImutExpr1::Record(Box::new(record)),
    <list:List> => ImutExpr1::List(Box::new(list)),
    <s:StringLiteral> => ImutExpr1::String(s)

}

////////////////////////////// Expr (immutable) ////////////////////////////////////////
// Imutable exprssions are used in parts of the lgnauge that are not suposed to
// modify the event, locals, or metadata.

/// Expression root
ExprImut: ImutExpr1<'input> = {
    OrExprImut => <>,
}

/// Logical or
OrExprImut: ImutExpr1<'input> = {
    <o:BinOp<BinOr, ExprImut, AndExprImut>> => <>,
    AndExprImut => <>,
}

/// Logical and
AndExprImut: ImutExpr1<'input> = {
    BinOp<BinAnd, AndExprImut, EqExprImut> => <>,
    EqExprImut => <>,
}

/// Equality compairison operators
EqExprImut: ImutExpr1<'input> = {
    BinOp<BinEq, EqExprImut, CmpExprImut> => <>,
    CmpExprImut => <>,
}

/// Relational compairison operators
CmpExprImut: ImutExpr1<'input> = {
    BinOp<BinCmp, CmpExprImut, AddExprImut> => <>,
    AddExprImut => <>,
}

/// Addition based math (+, -)
AddExprImut: ImutExpr1<'input> = {
    BinOp<BinAdd, AddExprImut, MulExprImut> => <>,
    MulExprImut => <>,
}

/// Multiplication based math (*, /, %)
MulExprImut: ImutExpr1<'input> = {
    BinOp<BinMul, MulExprImut, UnaryExprImut> => <>,
    UnaryExprImut => <>,
}

/// Mathematical unary expressions (unary +, unary - )
UnaryExprImut: ImutExpr1<'input> = {
    <start:@L> "+" <expr:UnaryExprImut> <end:@L> => ImutExpr1::Unary(Box::new(UnaryExpr1 { kind: UnaryOpKind::Plus, expr: expr, start, end })),
    <start:@L> "-" <expr:UnaryExprImut> <end:@L> => ImutExpr1::Unary(Box::new(UnaryExpr1 { kind: UnaryOpKind::Minus, expr: expr, start, end })),
    UnarySimpleExprImut => <>,
}


/// Logical unary expressions (not)
UnarySimpleExprImut: ImutExpr1<'input> = {
    <start:@L> "not" <expr:PresenceSimplExprImut> <end:@L> => ImutExpr1::Unary(Box::new(UnaryExpr1 { kind: UnaryOpKind::Not, expr: expr, start, end })),
    PresenceSimplExprImut => <>,
}

/// Presence operations (present, absent)
PresenceSimplExprImut: ImutExpr1<'input> = {
    <start:@L> "present" <path:Path> <end:@L> => ImutExpr1::Present{path, start, end},
    <start:@L> "absent" <path:Path> <end:@L> => ImutExpr1::Unary(Box::new(UnaryExpr1 { kind: UnaryOpKind::Not, expr: ImutExpr1::Present{path, start, end}, start, end })),
    SimpleExprImut => <>,
}

/// Imutable languag constructs that can be used without having to worry aobut
/// sideeffects

ComplexExprImut: ImutExpr1<'input> = {
    <pp:MatchImut> => ImutExpr1::Match(Box::new(pp)),
    <comprehension:ForImut> => ImutExpr1::Comprehension(Box::new(comprehension)),
    ExprImut => <>
}

SimpleExprImut: ImutExpr1<'input> = {
    "(" <expr:ComplexExprImut> ")" => expr,
    AlwaysImutExpr => <>
}

////////////////////////////// Literals and semi literals //////////////////////////////
// This section covers literals (strings, nil, etc) and semi literals.
// At this stage Lists and Records are considered semi literals
// as we only decide in the next step if they are literals or include
// variables and need to get constructed during runtime.

/// Basic literals
Literal: Literal<'input> = {
    <start:@L> <v:Nil> <end:@L> => Literal{value: v, start, end},
    <start:@L> <v:Bool> <end:@L> => Literal{value: v, start, end},
    <start:@L> <v:Int> <end:@L> => Literal{value: v, start, end},
    <start:@L> <v:Float> <end:@L> => Literal{value: v, start, end},
}

/// null
Nil: Value<'input> = {
    <literal:"nil">  => Value::Null,
}

/// booleans
Bool: Value<'input> = {
    <literal:"bool"> =>  Value::from(literal),
}

/// integers
Int: Value<'input> = {
    <literal:"int">  => Value::from(literal as i64),
}

/// floats
Float: Value<'input> = {
    <literal:"float"> => Value::from(literal.0),
}

                                                                                                                                                                                                                                                                                                  StringLiteral: StringLit1<'input> = {
    <start:@L> <doc:"heredoc"> <end:@L> =>   StringLit1 {
        start,
        end,
        string: doc.join("\n").into(),
        exprs: vec![],
    },
    <start:@L> "\"" <es:StrLitElements> "\"" <end:@L> => {
        let mut sl: StringLit1 = es.into();
        sl.start = start;
        sl.end = end;
        sl
    },
    <start:@L> "\""  "\"" <end:@L> => {
        StringLit1 {
            start,
            end,
            string: "".into(),
            exprs: vec![],
        }
    },
}

StrLitElements: StrLitElements<'input> = {
    <literal:StringPart> <es:StrLitElements> => {
        let mut es = es;
        es.0.push(literal);
        es
    },
    "{" <expr:ExprImut> "}" <es:StrLitElements> => {
        let mut es = es;
        es.0.push("{}".into());
        es.1.push(expr);
        es
    },
    <literal:StringPart> => StrLitElements(vec![literal], vec![]),
    "{" <expr:ExprImut> "}" => StrLitElements(vec!["{}".into()], vec![expr]),
}

StringPart: Cow<'input, str> = {
    "string" => <>
}
/// array semi literals
List: List1<'input> = {
    <start:@L> "[" <exprs:ListElements> "]" <end:@L> => List1{start, end, exprs},
    <start:@L> "[" "]" <end:@L> => List1{start, end, exprs: vec![]},
}

ListElements: ImutExprs1<'input> = {
    <fields:ListElements_> => {
        let mut fields = fields;
        fields.reverse();
        fields
    },
}

ListElements_: ImutExprs1<'input> = {
    <Sep<ListElements_, ComplexExprImut, ",">> => <>,
}

/// A semi literal record
Record: Record1<'input> = {
    <start:@L> "{" <fields:Fields> "}" <end:@L> => Record1 { fields: fields, start, end },
    <start:@L> "{" "}" <end:@L> => Record1 { fields: vec![], start, end }
}

/// Fields for a static record
Field: Field1<'input> = {
    <start:@L> <name:StringLiteral> ":" <value:ComplexExprImut> <end:@L> => {
        Field1 { name, value, start, end }
    }
}

////////////////////////////// Path ////////////////////////////////////////
// Path define lookups of data that is in either local variable, metadata
// or the event.

/// A path into one of the scopes
Path: Path1<'input> = {
    MetaPath => <>,
    EventPath => <>,
    LocalPath => <>,
    AggrPath => <>,
    ArgsPath => <>,
}

/// A metadata path
MetaPath: Path1<'input> = {
    <start:@L> "$" <segment:PathSegment> <segments:PathSegments> <end:@L> => {
        let mut segments = segments;
        segments.insert(0, segment);

        Path1::Meta(MetadataPath1 { segments, start, end })
    },
    <start:@L> "$" <segment:PathSegment> <end:@L> => {
        Path1::Meta(MetadataPath1 { segments: vec![segment], start, end })
    },
    <start:@L> "$" <end:@L> => Path1::Meta(MetadataPath1 { segments: vec![], start, end }),
}

/// A window/group path
AggrPath: Path1<'input> = {
    <start:@L> "group" <mid:@L> <segments:PathSegments> <end:@L> => {
        let mut segments = segments;
        segments.insert(0, Segment1::from_str("group", start, mid));
        Path1::Local(LocalPath1 { segments, start, end })
    },
    <start:@L> "group" <end:@L> => Path1::Local(LocalPath1 { segments: vec![Segment1::from_str("group", start, end)], start, end }),
    <start:@L> "window" <mid:@L> <segments:PathSegments> <end:@L> => {
        let mut segments = segments;
        segments.insert(0, Segment1::from_str("window", start, mid));
        Path1::Local(LocalPath1 { segments, start, end })
    },
    <start:@L> "window" <end:@L> => Path1::Local(LocalPath1 { segments: vec![Segment1::from_str("window", start, end)], start, end }),
}

/// Arguments to a script or function
ArgsPath: Path1<'input> = {
    <start:@L> "args" <mid:@L> <segments:PathSegments> <end:@L> => {
        let mut segments = segments;
        segments.insert(0, Segment1::from_str("args", start, mid));
        Path1::Local(LocalPath1 { segments, start, end })
    },
    <start:@L> "args" <end:@L> => Path1::Local(LocalPath1 { segments: vec![Segment1::from_str("args", start, end)], start, end }),
}

/// Local path
LocalPath: Path1<'input> = {
    <start:@L> <segment:PathSegment> <segments:PathSegments> <end:@L> => {
        let mut segments = segments;
        segments.insert(0, segment);
        Path1::Local(LocalPath1 { segments, start, end })
    },
    <start:@L> <segment:PathSegment> <end:@L> => {
        Path1::Local(LocalPath1 { segments:  vec![segment], start, end })
    },
}

/// Event path
EventPath: Path1<'input> = {
    <start:@L> "event" <segments:PathSegments> <end:@L> => Path1::Event(EventPath1 { segments, start, end }),
    <start:@L> "event" <end:@L> => Path1::Event(EventPath1 { segments: vec![], start, end }),
}

/// Segments of a path
PathSegments: Segments1<'input> = {
    "." <segment:PathSegment> <segments:PathSegments> => {
        let mut segments = segments;
        segments.insert(0, segment);
        segments
    },
    "[" <selector:Selector> "]" <segments:PathSegments> => {
        let mut segments = segments;
        segments.insert(0, selector);
        segments
    },
    "[" <selector:Selector> "]" => vec![selector],
    "." <segment:PathSegment> => vec![segment],
}

/// Singular part of a path
PathSegment: Segment1<'input> = {
    <id:Ident> => Segment1::from_id(id),
}


/// A path selector aka [...]
Selector: Segment1<'input> = {
    <start_lower:@L> <range_start:ComplexExprImut> <end_lower:@L> ":" <start_upper:@L> <range_end:ComplexExprImut> <end_upper:@L> => Segment1::Range{range_start, range_end, start_lower, end_lower, start_upper, end_upper},
    <start:@L> <expr:ComplexExprImut> <end:@L>  => Segment1::Element{expr, start, end},
}


////////////////////////////// Function invocations //////////////////////////////
// Function invocations consist of a module, function name and an
// argument list.

/// Function invocation
InvokeAggr: InvokeAggr1<'input> = {
    <start:@L> <module:Ident> "::" <fun:Ident> "[" <arg:ComplexExprImut> "]" <end:@L> => InvokeAggr1 { module: module.id.to_string(), fun: fun.id.to_string(), args: vec![arg], start, end },
}

/// Function invocation
Invoke: Invoke1<'input> = {
    <start:@L> <module:Ident> "::" <fun:Ident> "(" <args:InvokeArgs> ")" <end:@L> => Invoke1 { module: module.id.to_string(), fun: fun.id.to_string(), args, start, end },
    <start:@L> <module:Ident> "::" <fun:Ident> "(" ")" <end:@L> => Invoke1 { module: module.id.to_string(), fun: fun.id.to_string(), args: vec![], start, end },
}

InvokeArgs: ImutExprs1<'input> = {
    <fields:InvokeArgs_> => {
        let mut fields = fields;
        fields.reverse();
        fields
    },
}

InvokeArgs_: ImutExprs1<'input> = {
    <Sep<InvokeArgs_, ComplexExprImut, ",">> => <>,
}

////////////////////////////// Terminal expressions //////////////////////////////
// These expressions terminate execution.

/// drop the current event.
Drop: Expr1<'input> = {
    <start:@L> "drop" <end:@L> => Expr1::Drop{start, end } ,
}

/// emits the current event to a given output
Emit: Expr1<'input> = {
    <start:@L> "emit" <expr:ComplexExprImut> "=>" <port:StringLiteral> <end:@L> => Expr1::Emit(Box::new(EmitExpr1 { expr: expr, start, end, port: Some(ImutExpr1::String(port)) })),
    <start:@L> "emit" <expr:ComplexExprImut>  <end:@L> => Expr1::Emit(Box::new(EmitExpr1 { expr: expr, start, end, port: None })),
    <start:@L> "emit" "=>" <port:StringLiteral> <end:@L> => Expr1::Emit(Box::new(EmitExpr1 { expr: ImutExpr1::Path(Path1::Event(EventPath1 { segments: vec![], start, end })).into(), start, end, port: Some(ImutExpr1::String(port)) })) ,
    <start:@L> "emit" <end:@L> => Expr1::Emit(Box::new(EmitExpr1 { expr: ImutExpr1::Path(Path1::Event(EventPath1 { segments: vec![], start, end })).into(), start, end, port: None })),
}


////////////////////////////// Let expression  //////////////////////////////
// An expression that assigns a value to a variable

/// Let expression to assign values
Let: Expr1<'input> = {
// TODO FIXME investigate multi-let after `event` keyword +change
//    <start:@L> "let" <exprs:Assignments> <end:@L> "end" => Expr::Let(Let { exprs, start, end }),
    <start:@L> "let" <expr:Assignment> <end:@L> => expr, // Expr::Let(Let { exprs: vec![expr], start, end }),
}

// Assignments: Exprs = {
//     <list:Assignments> "," <expr:Assignment> => {
//         let mut list = list;
//         list.push(expr);
//         list
//     },
//     Assignment => vec![<>],
// }

Assignment: Expr1<'input> = {
    <start:@L> <path:Path> @L "=" @R <expr:SimpleExpr> <end:@L> => Expr1::Assign(Box::new(Assign1 { path, expr: expr, start, end })),
}

////////////////////////////// patch expression  //////////////////////////////
// Patches a input value with a set of instructions

Patch: Patch1<'input> = {
  // NOTE: ASSUMPTION array and literal targets are banned
    <start:@L> "patch" <target:ComplexExprImut> <end:@L> "of" <operations:PatchOperations> "end" => Patch1 { target, operations, start, end }
}

PatchOperations: PatchOperations1<'input> = {
    <e:PatchOperationClause> => vec![e],
    <v:PatchOperations> "," <e:PatchOperationClause> => {
    let mut v = v;
    v.push(e);
    v
  }
}

PatchField: ImutExpr1<'input> = {
    ComplexExprImut => <>
}

PatchOperationClause: PatchOperation1<'input> = {
    "insert" <ident:PatchField> "=>" <expr:ComplexExprImut> => PatchOperation1::Insert{ ident, expr },
    "upsert" <ident:PatchField> "=>" <expr:ComplexExprImut> => PatchOperation1::Upsert{ ident, expr },
    "update" <ident:PatchField> "=>" <expr:ComplexExprImut> => PatchOperation1::Update{ ident, expr },
    "erase" <ident:PatchField> => PatchOperation1::Erase{ ident },
    "move" <from:PatchField> "=>" <to:PatchField>  => PatchOperation1::Move{ from, to },
    "copy" <from:PatchField> "=>" <to:PatchField>  => PatchOperation1::Copy{ from, to },
    // "test" <ident:Ident> "=>" <expr:Expr> => PatchOperationClause { kind: PatchOperationKind::Add, ident, Some(expr) },
    "merge" <ident:PatchField> "=>" <expr:ComplexExprImut> => PatchOperation1::Merge { ident, expr },
    "merge" "=>" <expr:ComplexExprImut> => PatchOperation1::TupleMerge { expr },
}


////////////////////////////// merge expression  //////////////////////////////
// Merges a perge spec (record) into the target

Merge: Merge1<'input> = {
    <start:@L> "merge" <target:ComplexExprImut> "of" <expr:ComplexExprImut> "end" <end:@L> => Merge1 { target, expr, start, end }
}

////////////////////////////// for comprehension (mut)  //////////////////////////////
// Merges a perge spec (record) into the target

For: Comprehension1<'input> = {
    <start:@L> "for" <target:ComplexExprImut> "of" <cases:ForCaseClauses> "end" <end:@L> => Comprehension1{target, cases, start, end},
}

ForCaseClauses: ComprehensionCases1<'input> = {
    <e:ForCaseClause> => vec![e],
    <v:ForCaseClauses> <e:ForCaseClause> => {
        let mut v = v;
        v.push(e);
        v
    }
}

ForCaseClause: ComprehensionCase1<'input> = {
    "case" <start:@L>  "(" <k:Ident> "," <v:Ident> ")" <end:@L> <guard:WhenClause> <exprs:Effectors>  => ComprehensionCase1 { key_name: k.id, value_name: v.id, exprs, guard, start, end },
    "case" <start:@L> "(" <k:Ident> "," <v:Ident> ")" <end:@L> <exprs:Effectors> => ComprehensionCase1 { key_name: k.id, value_name: v.id, exprs, guard: None, start, end },
}

// ////////////////////////////// for comprehension (imutmut)  //////////////////////////////
// // Merges a perge spec (record) into the target

ForImut: ImutComprehension1<'input> = {
    <start:@L> "for" <target:ComplexExprImut> "of" <cases:ForCaseClausesImut> "end" <end:@L> => ImutComprehension1{target, cases, start, end},
}

ForCaseClausesImut: ImutComprehensionCases1<'input> = {
    <e:ForCaseClauseImut> => vec![e],
    <v:ForCaseClausesImut> <e:ForCaseClauseImut> => {
        let mut v = v;
        v.push(e);
        v
    }
}

ForCaseClauseImut: ImutComprehensionCase1<'input> = {
    "case" <start:@L>  "(" <k:Ident> "," <v:Ident> ")" <end:@L> <guard:WhenClause> <exprs:EffectorsImut>  => ImutComprehensionCase1 { key_name: k.id, value_name: v.id, exprs, guard, start, end },
    "case" <start:@L> "(" <k:Ident> "," <v:Ident> ")" <end:@L> <exprs:EffectorsImut> => ImutComprehensionCase1 { key_name: k.id, value_name: v.id, exprs, guard: None, start, end },
}

////////////////////////////// match expression (mutating)  //////////////////////////////
// An expression that assigns a value to a variable

/// A match expression
Match: Match1<'input> = {
    <start:@L> "match" <target:ComplexExprImut> "of" <patterns:Predicates> "end" <end:@L> => Match1 { target, patterns, start, end },
}

/// Predicates for a match statement (aka list of case statements)
Predicates: Predicates1<'input> = {
    <e:PredicateClause> => vec![e],
    <v:Predicates> <e:PredicateClause> => {
        let mut v = v;
        v.push(e);
        v
    }
}

/// A case statement 
PredicateClause: PredicateClause1<'input> = {
    <start:@L> "case" <rp:RecordCaseClause> <exprs:Effectors> <end:@L> => PredicateClause1 { pattern: rp, exprs, guard: None, start, end },
    <start:@L> "case" <rp:RecordCaseClause> <guard:WhenClause> <exprs:Effectors> <end:@L> => PredicateClause1 { pattern: rp, exprs, guard, start, end },
    <start:@L> "case" <ap:ArrayCaseClause> <exprs:Effectors> <end:@L> => PredicateClause1 { pattern: ap, exprs, guard: None, start, end },
    <start:@L> "case" <ap:ArrayCaseClause> <guard:WhenClause> <exprs:Effectors> <end:@L> => PredicateClause1 { pattern: ap, exprs, guard, start, end },
    <start:@L> "case" <lhs:ExprCaseClause> <rhs:Effectors> <end:@L> => PredicateClause1 { pattern: lhs, exprs: rhs, guard: None, start, end },
    <start:@L> "case" <lhs:ExprCaseClause> <guard:WhenClause> <rhs:Effectors> <end:@L> => PredicateClause1 { pattern: lhs, exprs: rhs, guard, start, end},
    <start:@L> "default" <exprs:Effectors> <end:@L> => PredicateClause1 { pattern: Pattern1::Default, exprs, guard: None, start, end },
}

/// Effoectors aka (=>  ... )
Effectors: Exprs1<'input> = {
    "=>" <exprs:Block> => exprs
}

/// The effectors for a case statement
Block: Exprs1<'input> = {
    <e:Expr> => vec![e],
    <v:Block> "," <e:Expr> => {
        let mut v = v;
        v.push(e);
        v
    }
}

////////////////////////////// match expression (non mutating)  //////////////////////////////
// An expression that assigns a value to a variable

/// A match expression
MatchImut: ImutMatch1<'input> = {
    <start:@L> "match" <target:ComplexExprImut> "of" <patterns:PredicatesImut> "end" <end:@L> => ImutMatch1 { target, patterns, start, end },
}

/// Predicates for a match statement (aka list of case statements)
PredicatesImut: ImutPredicates1<'input> = {
    <e:PredicateClauseImut> => vec![e],
    <v:PredicatesImut> <e:PredicateClauseImut> => {
        let mut v = v;
        v.push(e);
        v
    }
}

/// A case statement 
PredicateClauseImut: ImutPredicateClause1<'input> = {
    <start:@L> "case" <rp:RecordCaseClause> <exprs:EffectorsImut> <end:@L> => ImutPredicateClause1 { pattern: rp, exprs, guard: None, start, end },
    <start:@L> "case" <rp:RecordCaseClause> <guard:WhenClause> <exprs:EffectorsImut> <end:@L> => ImutPredicateClause1 { pattern: rp, exprs, guard, start, end },
    <start:@L> "case" <ap:ArrayCaseClause> <exprs:EffectorsImut> <end:@L> => ImutPredicateClause1 { pattern: ap, exprs, guard: None, start, end },
    <start:@L> "case" <ap:ArrayCaseClause> <guard:WhenClause> <exprs:EffectorsImut> <end:@L> => ImutPredicateClause1 { pattern: ap, exprs, guard, start, end },
    <start:@L> "case" <lhs:ExprCaseClause> <rhs:EffectorsImut> <end:@L> => ImutPredicateClause1 { pattern: lhs, exprs: rhs, guard: None, start, end },
    <start:@L> "case" <lhs:ExprCaseClause> <guard:WhenClause> <rhs:EffectorsImut> <end:@L> => ImutPredicateClause1 { pattern: lhs, exprs: rhs, guard, start, end},
    <start:@L> "default" <exprs:EffectorsImut> <end:@L> => ImutPredicateClause1 { pattern: Pattern1::Default, exprs, guard: None, start, end },
}

/// Effoectors aka (=>  ... )
EffectorsImut: ImutExprs1<'input> = {
    "=>" <exprs:BlockImut> => exprs
}

/// The effectors for a case statement
BlockImut: ImutExprs1<'input> = {
    <e:ComplexExprImut> => vec![e],
    <v:BlockImut> "," <e:ComplexExprImut> => {
        let mut v = v;
        v.push(e);
        v
    }
}

////////////////////////////// match expression (shared)  //////////////////////////////
// An expression that assigns a value to a variable

/// A record pattern aka [name = ] %{...}
RecordCaseClause: Pattern1<'input> = {
    <start:@L> <segment:Ident> "=" <rp:RecordPattern> <end:@L> => Pattern1::Assign(AssignPattern1 { id: segment.id, pattern: Box::new(Pattern1::Record(rp)) }),
    <rp:RecordPattern> => Pattern1::Record(rp),
}

/// A array pattern aka [name = ] %[...]
ArrayCaseClause: Pattern1<'input> = {
    <start:@L> <segment:Ident> "=" <ap:ArrayPattern> <end:@L> => Pattern1::Assign(AssignPattern1 { id:segment.id, pattern: Box::new(Pattern1::Array(ap)) }),
    <ap:ArrayPattern> => Pattern1::Array(ap),
}

/// An expression clause aka [name = ] <expr>
ExprCaseClause: Pattern1<'input> = {
    <start:@L> <segment:Ident> "=" <expr:ComplexExprImut> <end:@L> => Pattern1::Assign(AssignPattern1 { id:  segment.id, pattern: Box::new(Pattern1::Expr(expr)) }),
    <expr:ComplexExprImut> => Pattern1::Expr(expr),
}

/// When part of an expression (when ...)
WhenClause: Option<ImutExpr1<'input>> = {
    "when" <expr:ComplexExprImut> => Some(expr),
}


/// Predicate Patterns (aka tests) for record pattrens
PredicateFieldPattern: PredicatePattern1<'input> = {
    <start:@L> <lhs:Ident> <op:"~="> <expr:TestExpr> <end:@L> => PredicatePattern1::TildeEq { assign: lhs.id.clone(), lhs: lhs.id, test: expr},
    <start:@L> <assign:Ident> "=" <lhs:Ident> <op:"~="> <expr:TestExpr> <end:@L> => PredicatePattern1::TildeEq { assign: assign.id, lhs: lhs.id, test: expr} ,

    <start:@L> <lhs:Ident> <op:"~="> <rp:RecordPattern> <end:@L> => PredicatePattern1::RecordPatternEq { lhs: lhs.id, pattern: rp },
    <start:@L> <lhs:Ident> <op:"~="> <ap:ArrayPattern> <end:@L> => PredicatePattern1::ArrayPatternEq { lhs: lhs.id, pattern: ap },
    <start:@L> "present" <lhs:Ident> <end:@L> => PredicatePattern1::FieldPresent { lhs: lhs.id },
    <start:@L> "absent" <lhs:Ident> <end:@L> => PredicatePattern1::FieldAbsent { lhs: lhs.id },
    <lhs:Ident> <op:"=="> <expr:ComplexExprImut> => PredicatePattern1::Eq { lhs: lhs.id, rhs: expr, not: false },
    <lhs:Ident> <op:"!="> <expr:ComplexExprImut> => PredicatePattern1::Eq { lhs: lhs.id, rhs: expr, not: true },
}

TestExpr: TestExpr1 = {
    <start:@L> <id:Ident> <tl: TestLiteral> <end:@L> => {
        TestExpr1 { id: id.id.to_string(), test: tl, start, end}
    },
}

RecordPattern: RecordPattern1<'input> = {
    <start:@L> "%{" <fields:PatternFields> "}" <end:@L> => RecordPattern1 { fields: fields, start, end },
    <start:@L> "%{" "}" <end:@L> => RecordPattern1 { fields: vec![], start, end },
}

ArrayPattern: ArrayPattern1<'input> = {
    <start:@L> "%[" <exprs:ArrayPredicatePatterns> "]" <end:@L> => ArrayPattern1 { exprs, start, end },
}

ArrayPredicatePattern: ArrayPredicatePattern1<'input> = {
    "~" <test:TestExpr> => ArrayPredicatePattern1::Tilde(test),
    ComplexExprImut => ArrayPredicatePattern1::Expr(<>),
    RecordPattern => ArrayPredicatePattern1::Record(<>),
}

ArrayPredicatePatterns: ArrayPredicatePatterns1<'input> = {
    <list:ArrayPredicatePatterns> "," <item:ArrayPredicatePattern> => {
        let mut list = list;
        list.push(item);
        list
    },
    ArrayPredicatePattern => vec![<>],
}


PatternFields: PatternFields1<'input> = {
    <fields:PatternFields_> => {
        let mut fields = fields;
        fields.reverse();
        fields
    },
}

PatternFields_: PatternFields1<'input> = {
    <fields:Sep<PatternFields_, PredicateFieldPattern, ",">> => fields,
}


Fields: Fields1<'input> = {
    <fields:Fields_> => {
        let mut fields = fields;
        fields.reverse();
        fields
    },
}


Fields_: Fields1<'input> = {
    <fields:Sep<Fields_, Field, ",">> => fields,
}

#[inline]
Ident: Ident<'input> = {
    <start:@L> <name:"<ident>"> <end:@L> => Ident { id: name.0, start, end },
}

#[inline]
TestLiteral: String = {
    "test" => <>.join(""),
}

Sep<L, T, D>: L = {
    <item:T> D <list:L> => {
        let mut list = list;
        list.push(item);
        list
    },
    <item:T> D? => vec![item],
}

/// Generaic helper for binary operations
#[inline]
BinOp<Op, Current, Next>: ImutExpr1<'input> = {
    <start:@L> <lhs:(<Current>)> <op:(<Op>)> @L <rhs:Next> <end:@L> => ImutExpr1::Binary(Box::new(BinExpr1 {
        kind: op,
        lhs: lhs,
        rhs: rhs,
        start,
        end,
    })),
}

BinOr: BinOpKind = {
    "or" => BinOpKind::Or,
}
BinAnd: BinOpKind = {
    "and" => BinOpKind::And,
}
BinEq: BinOpKind = {
    "==" => BinOpKind::Eq,
    "!=" => BinOpKind::NotEq,
}
BinCmp: BinOpKind = {
    ">=" => BinOpKind::Gte,
    ">" => BinOpKind::Gt,
    "<=" => BinOpKind::Lte,
    "<" => BinOpKind::Lt,
}
BinAdd: BinOpKind = {
    "+" => BinOpKind::Add,
    "-" => BinOpKind::Sub,
}
BinMul: BinOpKind = {
    "*" => BinOpKind::Mul,
    "/" => BinOpKind::Div,
    "%" => BinOpKind::Mod,
}
extern {
    type Location = Location;
    type Error = crate::errors::Error;
    enum Token<'input> {
        "<doc-comment>" => Token::DocComment(<&'input str>),
        "<single-line-comment>" => Token::SingleLineComment(<&'input str>),
        "let" => Token::Let,
        "const" => Token::Const,
        "match" => Token::Match,
        "of" => Token::Of,
        "end" => Token::End,
        "case" => Token::Case,
        "when" => Token::When,
        "for" => Token::For,
        "nil" => Token::Nil,
        "and" => Token::And,
        "or" => Token::Or,
        "not" => Token::Not,
        "drop" => Token::Drop,
        "emit" => Token::Emit,
        "default" => Token::Default,
        "patch" => Token::Patch,
        "insert" => Token::Insert,
        "upsert" => Token::Upsert,
        "update" => Token::Update,
        "erase" => Token::Erase,
        "move" => Token::Move,
        "copy" => Token::Copy,
        "merge" => Token::Merge,
        "event" => Token::Event,
        "present" => Token::Present,
        "absent" => Token::Absent,
        "." => Token::Dot,
        "\"" => Token::DQuote,
        ";" => Token::Semi,
        "::" => Token::ColonColon,
        ":" => Token::Colon,
        "," => Token::Comma,
        "=" => Token::Eq,
//        "_" => Token::DontCare,
        "==" => Token::EqEq,
        "!=" => Token::NotEq,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "." => Token::Dot,
        "$" => Token::Dollar,
        "=>" => Token::EqArrow,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        ">=" => Token::Gte,
        ">" => Token::Gt,
        "<=" => Token::Lte,
        "<" => Token::Lt,
        "+" => Token::Add,
        "-" => Token::Sub,
        "*" => Token::Mul,
        "/" => Token::Div,
        "%[" => Token::LPatBracket,
        "%{" => Token::LPatBrace,
        "%" => Token::Mod,
        "~=" => Token::TildeEq,
        "~" => Token::Tilde,
        "bool" => Token::BoolLiteral(<bool>),
        "int" => Token::IntLiteral(<i64>),
        "float" => Token::FloatLiteral(<f64>, <String>),
        "string" => Token::StringLiteral(<Cow<'input, str>>),
        "heredoc" => Token::HereDoc(_, <Vec<String>>),
        "test" => Token::TestLiteral(_, <Vec<String>>),
        "<ident>" => Token::Ident(<Cow<'input, str>>, <bool>),
        "<error>" => Token::Bad(<String>),
        "<end-of-stream>" => Token::EndOfStream,

        "select" => Token::Select,
        "from" => Token::From,
        "into" => Token::Into,
        "create" => Token::Create,
        "tumbling" => Token::Tumbling,
        "sliding" => Token::Sliding,
        "window" => Token::Window,
        "stream" => Token::Stream,
        "operator" => Token::Operator,
        "where" => Token::Where,
        "with" => Token::With,
        "script" => Token::Script,
        "having" => Token::Having,
        "group" => Token::Group,
        "by" => Token::By,
        "define" => Token::Define,
        "args" => Token::Args,

        "set" => Token::Set,
        "each" => Token::Each,
    }
}


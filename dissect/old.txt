// Copyright 2018-2019, Wayfair GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#![forbid(warnings)]
//! Dissect is a library which is loosely based on logstash's dissect. It extracts data from
//! strings.
//!
//! ```rust
//! use dissect::{Dissect, Pattern, DissectError};
//! use simd_json::borrowed::Value;
//!
//! let filter = Pattern::try_from("%{a} %{b}")?;
//! let input = "John Doe";
//!
//! let output = filter.extract(input)?;
//! let mut expected = halfbrown::HashMap::new();
//! expected.insert("a".into(), Value::String("John".into()));
//! expected.insert("b".into(), Value::String("Doe".into()));
//!
//! assert_eq!(output, Dissect(expected));
//! # Ok::<(), DissectError>(())
//! ```
//!
//! ### Categories
//!
//! 1) Simple:
//!
//! Named fields can be extracted using the syntax %{<name>} where the given name is then used as a
//! key for the value. The characters between two fields are used as delimiters.
//!
//! ```rust
//! use dissect::{Dissect, Pattern, DissectError};
//! use simd_json::borrowed::Value;
//!
//! let output = Pattern::try_from("%{name}, %{age}")?;
//! let output = output.extract("John Doe, 22".into())?;
//! let mut expected = halfbrown::HashMap::new();
//! expected.insert("name".into(), Value::String("John Doe".into()));
//! expected.insert("age".into(), Value::String("22".into()));
//!
//! assert_eq!(output, Dissect(expected));
//! # Ok::<(), DissectError>(())
//! ```
//!
//! 2) Append (+)
//!
//! The append operator will append the value to another value creating an array.
//!
//! ```rust
//! use dissect::{Dissect, Pattern, DissectError};
//! use simd_json::borrowed::Value;
//! let output = Pattern::try_from( "%{+name} %{+name}, %{age}")?;
//! let output = output.extract("John Doe, 22")?;
//! let mut expected = halfbrown::HashMap::new();
//! expected.insert("name".into(), Value::String("John Doe".into()));
//! expected.insert("age".into(), Value::String("22".into()));
//!
//! assert_eq!(output, Dissect(expected));
//! # Ok::<(), DissectError>(())
//! ```
//!
//! Append works only on strings and doesn't support other types. Using append with any non-string
//! type will result in an error.
//!
//! 3) Named keys (&)
//!
//! The named operator will return a key value pair of the field. It takes the key from the
//! previous matched field. Given  the rule, `%{?name}, %{&name}` and input `"John Doe, 22"`,
//! the `"%{?name}"` will match `"John Doe"` but the `?` will prevent this from being stored
//! in the output.
//!
//! The seperator `, ` is skipped and `%{&name}` matches `"22"`. Since the `&` is used, name
//! doesn't become the key but the previous value found for  name `"John Doe"` even so isn't stored
//! in the output, will become the key for `"22"`.
//!
//!
//! ```rust
//! use dissect::{Dissect, Pattern, DissectError};
//! use simd_json::borrowed::Value;
//! let output = Pattern::try_from("%{?name}, %{&name}")?;
//! let output = output.extract( "John Doe, 22")?;
//! let mut expected = halfbrown::HashMap::new();
//! expected.insert("John Doe".into(), Value::String("22".into()));
//! assert_eq!(output, Dissect(expected));
//! # Ok::<(), DissectError>(())
//! ```
//!
//! 4) Empty fields
//!
//! Fields  will return an empty value if no data is present in the input.
//!
//! ```rust
//! use dissect::{Dissect, Pattern, DissectError};
//! use simd_json::borrowed::Value;
//!
//! let output = Pattern::try_from("%{name}, %{age}")?;
//! let output = output.extract(", 22")?;
//! let mut expected = halfbrown::HashMap::new();
//! expected.insert("name".into(), Value::String("".into()));
//! expected.insert("age".into(), Value::String("22".into()));
//! assert_eq!(output, Dissect(expected));
//! # Ok::<(), DissectError>(())
//! ```
//!
//! 5) Skipped fields (?)
//!
//! The operator will prevent the value from being stored in the output, effectively skipping it.
//!
//! ```rust
//! use dissect::{Dissect, Pattern, DissectError};
//! use simd_json::borrowed::Value;
//! let output = Pattern::try_from("%{?first_name} %{last_name}, %{age}")?;
//! let output = output.extract("John Doe, 22")?;
//! let mut expected = halfbrown::HashMap::new();
//! expected.insert("last_name".into(), Value::String("Doe".into()));
//! expected.insert("age".into(), Value::String("22".into()));
//! assert_eq!(output, Dissect(expected));
//! # Ok::<(), DissectError>(())
//! ```
//!
//! 6) Types
//!
//! We can convert the fields in the output to a different type by mentioning it in the field
//! definition. The types supported are: int, float, string. The type is specified with the
//! `field : type` syntax.
//!
//! ```rust
//!
//! use dissect::{Dissect, Pattern, DissectError};
//! use simd_json::borrowed::Value;
//! let output = Pattern::try_from("%{name}, %{age:int}")?;
//! let output = output.extract( "John Doe, 22")?;
//! let mut expected = halfbrown::HashMap::new();
//! expected.insert("name".into(), Value::String("John Doe".into()));
//! expected.insert("age".into(),Value::I64(22));
//! assert_eq!(output, Dissect(expected));
//! # Ok::<(), DissectError>(())
//! ```
//!
//! 7) Padding (_)
//!
//! The operator will remove padding when storing the field in the output. You can specify the
//! skipped character as a parameter to `_`. It will use ` ` by default.
//!
//! ```rust
//! use dissect::{Dissect, Pattern, DissectError};
//! use simd_json::borrowed::Value;
//! let output = Pattern::try_from("%{name}, %{_}%{age}")?;
//! let output = output.extract("John Doe,                22")?;
//! let mut expected = halfbrown::HashMap::new();
//! expected.insert("name".into(), Value::String("John Doe".into()));
//! expected.insert("age".into(), Value::String("22".into()));
//! assert_eq!(output, Dissect(expected));
//! # Ok::<(), DissectError>(())
//! ```
//!
//! ```rust
//! use dissect::{Dissect, Pattern, DissectError};
//! use simd_json::borrowed::Value;
//! let output = Pattern::try_from("%{name}, %{_(-)}%{age}")?;
//! let output = output.extract("John Doe, -----------------------22")?;
//! let mut expected = halfbrown::HashMap::new();
//! expected.insert("name".into(), Value::String("John Doe".into()));
//! expected.insert("age".into(), Value::String("22".into()));
//! assert_eq!(output, Dissect(expected));
//! # Ok::<(), DissectError>(())
//! ```
//!
use halfbrown::HashMap;
use simd_json::borrowed::Value as SimdValue;
use std::borrow::Cow;
use std::error::Error as ErrorTrait;
use std::fmt::{Display, Formatter, Result as FmtResult};

pub type Result<T> = std::result::Result<T, DissectError>;

// dissect parses the pattern and returns the token extracted from the input string. It will return
// an error if either the parsing or the extracting fails, and will return an error if it it doesn't
// match the token.

#[derive(Clone, PartialEq, Debug, Default)]
pub struct Pattern {
    tokens: Vec<Token>,
}

impl Pattern {
    pub fn new(tokens: Vec<Token>) -> Self {
        Pattern { tokens }
    }

    pub fn try_from(pattern: &str) -> Result<Self> {
        Ok(Pattern::new(lex(pattern)?))
    }

    pub fn extract<'dissect>(&'dissect self, input: &str) -> Result<Dissect<'dissect>> {
        Ok(Dissect(
            extract(&self.tokens, input)?
                .iter()
                .map(|(pat, x)| (pat.clone(), (x.to_owned().into())))
                .collect(),
        ))
    }
}

#[derive(Clone, PartialEq, Debug)]
pub struct Dissect<'dissect>(pub HashMap<Cow<'dissect, str>, SimdValue<'dissect>>);

impl<'dissect> std::ops::Deref for Dissect<'dissect> {
    type Target = HashMap<Cow<'dissect, str>, SimdValue<'dissect>>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum Token {
    Field(Field),
    Delimiter(String),
    Padding(String),
}

#[derive(Clone, Debug)]
pub struct Field {
    value: String,
    category: Option<FieldCategory>,
}

impl Field {
    pub fn from(value: &str, category: FieldCategory) -> Field {
        Field {
            value: value.to_owned(),
            category: Some(category),
        }
    }
}

impl PartialEq for Field {
    fn eq(&self, other: &Field) -> bool {
        self.value == other.value
    }
}

impl From<String> for Field {
    fn from(value: String) -> Field {
        Field {
            value,
            category: None,
        }
    }
}

impl From<&str> for Field {
    fn from(value: &str) -> Field {
        Field {
            value: value.to_string(),
            category: None,
        }
    }
}

#[derive(Clone, Debug, PartialEq)]
pub enum FieldCategory {
    Skipped,
    Append(String),
    Typed(SupportedType),
    Named,
    NamedTyped(SupportedType),
}

#[derive(Clone, Debug, PartialEq)]
pub enum Value {
    String(String),
    Integer(i32),
    Float(f32),
}

impl<'dissect> From<Value> for SimdValue<'dissect> {
    fn from(x: Value) -> SimdValue<'dissect> {
        match x {
            Value::String(s) => SimdValue::String(s.into()),
            Value::Integer(i) => SimdValue::I64(i.into()),
            Value::Float(f) => SimdValue::F64(f.into()),
        }
    }
}

#[derive(Clone, Debug, PartialEq)]
pub enum SupportedType {
    String,
    Integer,
    Float,
}

impl Display for SupportedType {
    fn fmt(&self, f: &mut Formatter) -> FmtResult {
        match self {
            SupportedType::String => write!(f, "string"),
            SupportedType::Integer => write!(f, "int"),
            SupportedType::Float => write!(f, "float"),
        }
    }
}

pub fn lex(pattern: &str) -> Result<Vec<Token>> {
    if pattern.is_empty() {
        Ok(vec![])
    } else {
        let tokens: Vec<usize> = pattern.match_indices("%{").map(|(k, _)| k).collect();
        if tokens.is_empty() {
            Ok(vec![(Token::Delimiter(pattern.to_string()))])
        } else {
            let mut matched_tokens = vec![];
            let iter = tokens.iter();
            let mut iter = iter.peekable();
            let len = pattern.len();

            // string starts with delimiters so we skip the tokens till we find a token.
            if tokens[0] != 0 {
                matched_tokens.push(Token::Delimiter(pattern[..tokens[0]].to_string()));
            }
            while let Some(index) = iter.next() {
                if let Some(offset) = pattern[index + 2..].find(|ch| ch == '}') {
                    let token_text = pattern[*index + 2..*index + 2 + offset].to_string();
                    match (&token_text.get(0..=0), &token_text.get(1..)) {
                        (Some("_"), Some("")) => {
                            matched_tokens.push(Token::Padding(" ".to_string()))
                        }
                        (Some("_"), Some(bracket_pad)) => {
                            if bracket_pad.starts_with('(') {
                                if let Some(pad_end) = bracket_pad.rfind(')') {
                                    matched_tokens
                                        .push(Token::Padding(bracket_pad[1..pad_end].to_string()));
                                } else {
                                    return Err(DissectError::ParseError(
                                        ParseError::InvalidPadding(bracket_pad.to_string(), *index),
                                    ));
                                }
                            } else {
                                return Err(DissectError::ParseError(ParseError::InvalidPadding(
                                    bracket_pad.to_string(),
                                    *index,
                                )));
                            }
                        }
                        (Some("?"), Some("")) => {
                            return Err(DissectError::ParseError(ParseError::InvalidToken(
                                "?".to_string(),
                                *index,
                            )));
                        }
                        (Some("?"), Some(field)) => {
                            matched_tokens
                                .push(Token::Field(Field::from(field, FieldCategory::Skipped)));
                        }
                        (Some("+"), Some(field)) => {
                            let x = matched_tokens.iter().find(|x| {
                                if let Token::Field(f) = x {
                                    f.value == *field
                                } else {
                                    false
                                }
                            });

                            match x {
                                Some(Token::Field(ref x)) => match x.category {
                                    Some(FieldCategory::Typed(_))
                                    | Some(FieldCategory::NamedTyped(_)) => {
                                        let cix =
                                            x.value.find(':').unwrap_or_else(|| x.value.len());

                                        return Err(DissectError::ParseError(
                                            ParseError::AppendDoesNotSupportTypes(
                                                x.value[0..cix].to_owned(),
                                                *index,
                                            ),
                                        ));
                                    }
                                    _ => {
                                        if field.contains(':') {
                                            return Err(DissectError::ParseError(
                                                ParseError::AppendDoesNotSupportTypes(
                                                    x.value.to_owned(),
                                                    *index,
                                                ),
                                            ));
                                        } else {
                                            matched_tokens.push(Token::Field(Field::from(
                                                field,
                                                FieldCategory::Append(field.to_owned().to_owned()),
                                            )));
                                        }
                                    }
                                },
                                _ => {
                                    if field.contains(':') {
                                        let cix = field.find(':').unwrap_or_else(|| field.len());

                                        return Err(DissectError::ParseError(
                                            ParseError::AppendDoesNotSupportTypes(
                                                field[0..cix].to_owned().to_owned(),
                                                *index,
                                            ),
                                        ));
                                    } else {
                                        matched_tokens.push(Token::Field(Field::from(
                                            field,
                                            FieldCategory::Append(field.to_owned().to_owned()),
                                        )));
                                    }
                                }
                            }
                        }

                        (Some("&"), Some(field)) => {
                            if field.contains(':') {
                                let parts = field.split(':').collect::<Vec<&str>>();
                                let field = parts[0];
                                if parts.len() == 2 {
                                    let datatype = match parts[1] {
                                        "int" => Ok(SupportedType::Integer),
                                        "float" => Ok(SupportedType::Float),
                                        "string" => Ok(SupportedType::String),
                                        _ => Err(DissectError::ParseError(
                                            ParseError::TypeNotSupported(parts[1].to_string()),
                                        )),
                                    }?;

                                    matched_tokens.push(Token::Field(Field::from(
                                        field,
                                        FieldCategory::NamedTyped(datatype),
                                    )));
                                } else {
                                    return Err(DissectError::ParseError(
                                        ParseError::InvalidToken(field.to_owned(), *index),
                                    ));
                                }
                            } else {
                                matched_tokens
                                    .push(Token::Field(Field::from(field, FieldCategory::Named)));
                            }
                        }

                        (Some(f), token) => {
                            let token = f.to_owned().to_owned() + token.unwrap_or("");

                            let parts = token.split(':').collect::<Vec<&str>>();

                            match parts.len() {
                                1 => {
                                    if let Some(Token::Field(_)) = matched_tokens.last() {
                                        return Err(DissectError::ParseError(
                                            ParseError::NoDelimiter(*index),
                                        ));
                                    } else {
                                        matched_tokens.push(Token::Field(token_text.into()));
                                    }
                                }

                                2 => {
                                    let field = parts[0];
                                    let datatype = match parts[1].trim() {
                                        "int" => Ok(SupportedType::Integer),
                                        "float" => Ok(SupportedType::Float),
                                        "string" => Ok(SupportedType::String),
                                        _ => Err(DissectError::ParseError(
                                            ParseError::TypeNotSupported(parts[1].to_string()),
                                        )),
                                    }?;

                                    matched_tokens.push(Token::Field(Field::from(
                                        field,
                                        FieldCategory::Typed(datatype),
                                    )));
                                }
                                _ => {
                                    return Err(DissectError::ParseError(
                                        ParseError::InvalidToken(token, *index),
                                    ));
                                }
                            }
                        }
                        (None, _) => {
                            matched_tokens
                                .push(Token::Field(Field::from("", FieldCategory::Skipped)));
                        }
                    }

                    match iter.peek() {
                        Some(delim_index) if **delim_index < offset => {
                            return Err(DissectError::ParseError(
                                ParseError::MissingClosingBracket(*index),
                            ));
                        }
                        Some(delim_index) => {
                            let delimiter = pattern[index + offset + 3..**delim_index].to_string();
                            if !delimiter.is_empty() {
                                matched_tokens.push(Token::Delimiter(delimiter));
                            }
                        }
                        _ => {
                            let delimiter = pattern[index + offset + 3..].to_string();
                            if !delimiter.is_empty() {
                                matched_tokens.push(Token::Delimiter(delimiter));
                            }
                        }
                    }

                    pattern[index + 2 + offset + 1..**iter.peek().unwrap_or(&&len)].to_string();
                } else {
                    return Err(DissectError::ParseError(ParseError::MissingClosingBracket(
                        *index,
                    )));
                }
            }
            Ok(matched_tokens)
        }
    }
}

pub fn extract<'dissect>(
    tokens: &'dissect [Token],
    input: &str,
) -> Result<HashMap<Cow<'dissect, str>, Value>> {
    let iter = tokens.iter();
    let mut data = input;
    let mut iter = iter.enumerate().peekable();
    let mut output = HashMap::<Cow<'dissect, str>, Value>::new();
    let mut skipped_values = vec![];
    let mut delimiters = vec![];
    while let Some((idx, token)) = iter.next() {
        match token {
            Token::Field(pat) => {
                let (extract, d) = match iter.peek() {
                    Some((_, Token::Delimiter(delim))) => match data.find(delim.as_str()) {
                        Some(x) => {
                            delimiters.push((pat, delim));
                            (data[..x].to_string(), &data[x..])
                        }
                        None => {
                            return Err(DissectError::RuntimeError(
                                RuntimeError::NoDelimiterInInput(delim.to_owned()),
                            ));
                        }
                    },

                    Some((_, Token::Padding(_))) => {
                        let pad_iter = iter.clone();

                        let mut stop_after_first_delim = true;
                        let non_tokens: Vec<Token> = pad_iter
                            .take_while(|(_, x)| match x {
                                Token::Padding(_) => true,
                                Token::Delimiter(_) if stop_after_first_delim => {
                                    stop_after_first_delim = false;
                                    true
                                }

                                _ => false,
                            })
                            .map(|(_, x)| x.to_owned())
                            .collect();

                        let mut ex = (String::from(data), "");

                        let _ = non_tokens.iter().rev().find(|x| match x {
                            Token::Delimiter(delim) | Token::Padding(delim) => {
                                match data.find(delim) {
                                    Some(y) => {
                                        ex = (data[..y].to_owned(), &data[y..]);
                                        true
                                    }
                                    None => false,
                                }
                            }
                            _ => {
                                ex = (data.to_owned(), "");
                                false
                            }
                        });

                        non_tokens.iter().rev().for_each(|nt| {
                            if let Token::Padding(p) = nt {
                                ex.0 = ex.0.trim_end_matches(p).to_owned();
                                ex.1 = ex.1.trim_start_matches(p);
                            }
                        });

                        ex
                    }
                    None => {
                        if data == "" {
                            return Err(DissectError::RuntimeError(
                                RuntimeError::AllTokensNotExhausted(idx),
                            ));
                        } else {
                            (data.to_owned(), "")
                        }
                    }
                    // two consecutive tokens is invalid
                    _ => unreachable!(),
                };

                match pat.category {
                    Some(FieldCategory::Skipped) => {
                        skipped_values.push((pat.value.to_owned(), extract));
                    }
                    Some(FieldCategory::Typed(ref datatype)) => {
                        let value = match datatype {
                            SupportedType::Integer => {
                                extract.parse::<i32>().map(Value::Integer).map_err(|_| {
                                    DissectError::RuntimeError(
                                        RuntimeError::CannotParseValueToType(
                                            extract,
                                            SupportedType::Integer,
                                        ),
                                    )
                                })?
                            }
                            SupportedType::Float => {
                                extract.parse::<f32>().map(Value::Float).map_err(|_| {
                                    DissectError::RuntimeError(
                                        RuntimeError::CannotParseValueToType(
                                            extract,
                                            SupportedType::Float,
                                        ),
                                    )
                                })?
                            }
                            _ => Value::String(extract.to_owned()),
                        };

                        output.insert(
                            Into::<Cow<'dissect, str>>::into(pat.value.to_string()),
                            value,
                        );
                    }

                    Some(FieldCategory::Named) => {
                        match skipped_values.iter().rev().find(|(x, _)| *x == pat.value) {
                            Some((_, field)) => {
                                output.insert(
                                    field.to_string().into(),
                                    Value::String(extract.clone()),
                                );
                            }
                            None => {
                                return Err(DissectError::RuntimeError(
                                    RuntimeError::FieldNameNotFound(pat.value.to_string()),
                                ));
                            }
                        }
                    }

                    Some(FieldCategory::NamedTyped(ref datatype)) => {
                        match skipped_values.iter().rev().find(|(x, _)| *x == pat.value) {
                            Some((_, field)) => {
                                let value = match datatype {
                                    SupportedType::Integer => extract
                                        .parse::<i32>()
                                        .map(Value::Integer)
                                        .map_err(|_| {
                                            DissectError::RuntimeError(
                                                RuntimeError::CannotParseValueToType(
                                                    extract,
                                                    SupportedType::Integer,
                                                ),
                                            )
                                        })?,

                                    SupportedType::Float => {
                                        extract.parse::<f32>().map(Value::Float).map_err(|_| {
                                            DissectError::RuntimeError(
                                                RuntimeError::CannotParseValueToType(
                                                    extract,
                                                    SupportedType::Float,
                                                ),
                                            )
                                        })?
                                    }
                                    SupportedType::String => Value::String(extract.to_string()),
                                };

                                output.insert(field.to_string().into(), value.clone());
                            }
                            None => {
                                return Err(DissectError::RuntimeError(
                                    RuntimeError::FieldNameNotFound(pat.value.to_string()),
                                ));
                            }
                        }
                    }
                    Some(FieldCategory::Append(_)) => match output
                        .get_mut(&Cow::Borrowed(pat.value.as_str()))
                    {
                        Some(entry) => match entry {
                            Value::String(s) => {
                                let en = match iter.peek() {
                                    Some((_, Token::Delimiter(_))) => {
                                        match delimiters.iter().find(|(p, _)| p.value == pat.value)
                                        {
                                            Some((_, prev_delim)) => {
                                                Value::String(s.to_owned() + prev_delim + &extract)
                                            }

                                            _ => Value::String(s.to_owned() + &extract),
                                        }
                                    }
                                    None => {
                                        if let Some((_, prev_delim)) =
                                            delimiters.iter().find(|(p, _)| p.value == pat.value)
                                        {
                                            Value::String(s.to_owned() + prev_delim + &extract)
                                        } else {
                                            Value::String(s.to_owned() + &extract)
                                        }
                                    }
                                    _ => unreachable!(),
                                };
                                output.insert(pat.value.to_string().into(), en);
                            }
                            _ => unreachable!(),
                        },
                        _ => {
                            output.insert(
                                pat.value.clone().into(),
                                Value::String(extract.to_string()),
                            );
                        }
                    },
                    _ => {
                        output.insert(pat.clone().value.into(), Value::String(extract.to_string()));
                    }
                }
                data = d;
            }

            Token::Delimiter(d) => {
                if data.starts_with(d.as_str()) {
                    data = &data[d.len()..];
                } else {
                    return Err(DissectError::RuntimeError(
                        RuntimeError::NoDelimiterInInput(d.to_owned()),
                    ));
                }
            }

            Token::Padding(pad) => {
                data = &data.trim_start_matches(pad.as_str());
            }
        }
    }

    if !data.is_empty() {
        let len = input.find(data).unwrap_or(0);
        Err(DissectError::RuntimeError(
            RuntimeError::InputNotCompletelyParsed(len),
        ))
    } else {
        Ok(output)
    }
}
#[derive(Debug, PartialEq)]
pub enum ParseError {
    MissingClosingBracket(usize),
    NoDelimiter(usize),
    InvalidPadding(String, usize),
    InvalidToken(String, usize),
    TypeNotSupported(String),
    AppendDoesNotSupportTypes(String, usize),
}

#[derive(Debug, PartialEq)]
pub enum RuntimeError {
    NoDelimiterInInput(String),
    FieldNameNotFound(String),
    CannotParseValueToType(String, SupportedType),
    InputNotCompletelyParsed(usize),
    AllTokensNotExhausted(usize),
}

impl Display for ParseError {
    fn fmt(&self, f: &mut Formatter) -> FmtResult {
        match self {
            ParseError::MissingClosingBracket(index) => {
                write!(f, "The {{ at {} has no matching }}", index)
            }
            ParseError::NoDelimiter(index) => write!(f, "No delimiter between tokens at {}", index),
            ParseError::InvalidPadding(pad, index) => {
                write!(f, "Invalid padding {} at {}", pad, index)
            }
            ParseError::InvalidToken(token, index) => {
                write!(f, "Invalid token {} at {}", token, index)
            }
            ParseError::TypeNotSupported(datatype) => write!(f, "Type {} not supported", datatype),
            ParseError::AppendDoesNotSupportTypes(field, _) => {
                write!(f, "Can't use types with append for field {}", field)
            }
        }
    }
}

impl Display for RuntimeError {
    fn fmt(&self, f: &mut Formatter) -> FmtResult {
        match self {
            RuntimeError::NoDelimiterInInput(delim) => {
                write!(f, "Missing delimiter {} in the input", delim)
            }
            RuntimeError::FieldNameNotFound(field) => write!(f, "named field {} not found", field),
            RuntimeError::CannotParseValueToType(value, datatype) => {
                write!(f, "Cannot parse value {} to type {}", value, datatype)
            }
            RuntimeError::InputNotCompletelyParsed(index) => {
                write!(f, "Input not completely parsed starting at {}", index)
            }
            RuntimeError::AllTokensNotExhausted(idx) => {
                write!(f, "Tokens still remaining to be parsed from {}", idx)
            }
        }
    }
}

impl ErrorTrait for ParseError {}
impl ErrorTrait for RuntimeError {}
impl ErrorTrait for DissectError {}

#[derive(Debug, PartialEq)]
pub enum DissectError {
    ParseError(ParseError),
    RuntimeError(RuntimeError),
}

impl Display for DissectError {
    fn fmt(&self, f: &mut Formatter) -> FmtResult {
        write!(f, "{:?}", self)
    }
}

